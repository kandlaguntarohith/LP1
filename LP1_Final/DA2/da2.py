# -*- coding: utf-8 -*-
"""DA2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yorVmncBCAoCrPQKLVrd0hSOWdMhwtfG
"""

import pandas as pd
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
import numpy as np
from sklearn.metrics import accuracy_score, confusion_matrix

df = pd.read_csv('diabetes.csv')
df.head()

temp = df.groupby("Outcome").size()
temp

y = df['Outcome']
# drop the col 'outcome'
x = df.drop(['Outcome'],axis=1)

# Split data into train & test
x_train, x_test, y_train, y_test = train_test_split(x, y, stratify=y, random_state=42)

x_train.describe()

x_test.describe()

train_mean_pos = x_train[y_train==1].mean()
train_std_pos = x_train[y_train==1].std()
train_mean_neg = x_train[y_train==0].mean()
train_std_neg = x_train[y_train==0].std()

from math import sqrt
from math import pi
from math import exp
# formula of Gausian NB
def cond_probability(x, mean, std):
  exponent = exp(-((x - mean)**2/(2*std**2)))
  return (1 / (sqrt(2*pi)*std)) * exponent

def predict(row):
  prob_pos = len(x_train[y_train==1]) / len(x_train)
  for i in range(0,len(row)):
    prob_pos = prob_pos * cond_probability(row[i],train_mean_pos[i],train_std_pos[i])
  prob_neg = len(x_train[y_train==0]) / len(x_train)
  for i in range(0,len(row)):
    prob_neg = prob_neg * cond_probability(row[i],train_mean_neg[i],train_std_neg[i])
  return [prob_pos,prob_neg]

predictions_raw = []
for row in x_test.values.tolist():
  predictions_raw.append(predict(row))

predictions_raw[0]

predictions_raw

predictions = []
for row in predictions_raw:
  if(row[0]>row[1]):
    predictions.append(1)
  else:
    predictions.append(0)

# comparing our predictions and actual output for accuracy
accuracy_score(y_test.tolist(),predictions)

# plotting the output for comparison
confusion_matrix(y_test.tolist(),predictions)

model = GaussianNB() # Gaussian NB has been used becuase the data is continuous
model.fit(x_train,y_train)

confusion_matrix(y_test,model.predict(x_test))